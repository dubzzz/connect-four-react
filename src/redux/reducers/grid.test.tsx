import * as fc from 'fast-check';
import { emptyGrid, playToken } from './grid';
import { Player } from '../../models/player';

describe('emptyGrid', () => {
  it('Should generate grids with the right dimensions', () =>
    fc.assert(
      fc.property(fc.nat(50), fc.nat(50), (width, height) => {
        const grid = emptyGrid(width, height);
        return grid.length === height && grid.every(row => row.length === width);
      })
    ));
  it('Should generate empty grids', () =>
    fc.assert(
      fc.property(fc.nat(50), fc.nat(50), (width, height) => {
        const grid = emptyGrid(width, height);
        return grid.every(row => row.every(cell => cell === Player.None));
      })
    ));
});

const GridWidth = 7;
const GridHeight = 6;
const playerArb = fc.constantFrom(Player.PlayerA, Player.PlayerB);
const gridArb = fc.genericTuple([...Array(GridWidth)].map(_ => fc.array(playerArb, 0, GridHeight))).map(gridSchema => {
  const grid = emptyGrid(GridWidth, GridHeight);
  for (let i = 0; i !== gridSchema.length; ++i)
    for (let j = 0; j !== gridSchema[i].length; ++j) grid[GridHeight - j - 1][i] = gridSchema[i][j];
  return grid;
});
const playOnGridArb = fc
  .tuple(gridArb, fc.nat())
  .map(([grid, seed]) => {
    const playableColumns = grid[0].map((c, idx) => (c === Player.None ? idx : -1)).filter(id => id >= 0);
    return { grid, seed, playableColumns };
  })
  .filter(({ playableColumns }) => playableColumns.length > 0)
  .map(({ grid, seed, playableColumns }) => {
    // makes use of a seed generated by fast-check and not a Math.random
    // in order to be reproducible
    const selectedColumn = playableColumns[seed % playableColumns.length];
    return { grid, selectedColumn };
  });
const playOnFullColumnGridArb = fc.tuple(gridArb, fc.nat(GridWidth - 1)).map(([grid, selectedColumn]) => {
  const clonedGrid = grid.map(row => row.slice());
  for (let rowIdx = 0; rowIdx !== clonedGrid.length && clonedGrid[rowIdx][selectedColumn] === Player.None; ++rowIdx) {
    clonedGrid[rowIdx][selectedColumn] = Player.PlayerA;
  }
  return { grid: clonedGrid, selectedColumn };
});

describe('playToken', () => {
  it('Should put the token on top of the column', () =>
    fc.assert(
      fc.property(playOnGridArb, playerArb, ({ grid, selectedColumn }, player) => {
        const nextGrid = playToken(grid, selectedColumn, player);
        return nextGrid.map(row => row[selectedColumn]).find(c => c !== Player.None) === player;
      })
    ));
  it('Should add a single token in the grid', () =>
    fc.assert(
      fc.property(playOnGridArb, playerArb, ({ grid, selectedColumn }, player) => {
        const nextGrid = playToken(grid, selectedColumn, player);
        let numDiffs = 0;
        for (let j = 0; j !== grid.length; ++j)
          for (let i = 0; i !== grid[j].length; ++i) if (grid[j][i] !== nextGrid[j][i]) ++numDiffs;
        return numDiffs === 1;
      })
    ));
  it('Should throw on non playable column', () =>
    fc.assert(
      fc.property(playOnFullColumnGridArb, playerArb, ({ grid, selectedColumn }, player) => {
        expect(() => playToken(grid, selectedColumn, player)).toThrow();
      })
    ));
  it('Should not alter existing grid', () =>
    fc.assert(
      fc.property(playOnGridArb, playerArb, ({ grid, selectedColumn }, player) => {
        const clonedGrid = grid.map(row => row.slice());
        playToken(grid, selectedColumn, player);
        expect(grid).toEqual(clonedGrid);
      })
    ));
});

import * as fc from 'fast-check';
import { emptyGrid } from '../redux/reducers/grid';
import { playerArb } from './player';
import { Player } from '../models/player';

export const TestGridWidth = 7;
export const TestGridHeight = 6;
export const TestGridVictory = 4;

export const gridArb = fc
  .genericTuple([...Array(TestGridWidth)].map(_ => fc.array(playerArb, 0, TestGridHeight)))
  .map(gridSchema => {
    const grid = emptyGrid(TestGridWidth, TestGridHeight);
    for (let i = 0; i !== gridSchema.length; ++i)
      for (let j = 0; j !== gridSchema[i].length; ++j) grid[TestGridHeight - j - 1][i] = gridSchema[i][j];
    return grid;
  });

export const playOnGridArb = fc
  .tuple(gridArb, fc.nat())
  .map(([grid, seed]) => {
    const playableColumns = grid[0].map((c, idx) => (c === Player.None ? idx : -1)).filter(id => id >= 0);
    return { grid, seed, playableColumns };
  })
  .filter(({ playableColumns }) => playableColumns.length > 0)
  .map(({ grid, seed, playableColumns }) => {
    // makes use of a seed generated by fast-check and not a Math.random
    // in order to be reproducible
    const selectedColumn = playableColumns[seed % playableColumns.length];
    return { grid, selectedColumn };
  });
export const playOnFullColumnGridArb = fc.tuple(gridArb, fc.nat(TestGridWidth - 1)).map(([grid, selectedColumn]) => {
  const clonedGrid = grid.map(row => row.slice());
  for (let rowIdx = 0; rowIdx !== clonedGrid.length && clonedGrid[rowIdx][selectedColumn] === Player.None; ++rowIdx) {
    clonedGrid[rowIdx][selectedColumn] = Player.PlayerA;
  }
  return { grid: clonedGrid, selectedColumn };
});

const computeNextRow = (grid: Player[][], col: number) => {
  // compute the index of the row corresponding to the next token in col
  const lastInColumn = grid.findIndex(row => row[col] !== Player.None);
  return lastInColumn === -1 ? grid.length - 1 : lastInColumn - 1;
};
const replaceOrFillForPlayer = (grid: Player[][], player: Player, row: number, col: number) => {
  // fill [row][col] with selected player
  // while keeping a valid connect four grid (ie also fill the hole below [row][col] if necessary)
  if (grid[row][col] === Player.None) {
    for (let j = row; j !== grid.length && grid[j][col] === Player.None; ++j) {
      grid[row][col] = player;
    }
  } else {
    grid[row][col] = player;
  }
  return grid;
};
export const lineVictoryPlayOnGridArb = fc
  .tuple(playOnGridArb, playerArb, fc.integer(-TestGridVictory + 1, 0))
  .filter(
    ([{ grid, selectedColumn }, _player, offset]) =>
      selectedColumn + offset >= 0 && selectedColumn + offset + TestGridVictory <= grid[0].length
  )
  .map(([{ grid, selectedColumn }, player, offset]) => {
    const clonedGrid = grid.map(row => row.slice());
    const selectedRow = computeNextRow(grid, selectedColumn);
    for (let idx = 0; idx !== TestGridVictory; ++idx) {
      const col = selectedColumn + offset + idx;
      if (col === selectedColumn) continue;
      replaceOrFillForPlayer(clonedGrid, player, selectedRow, col);
    }
    return { grid: clonedGrid, selectedColumn, player };
  });
export const columnVictoryPlayOnGridArb = fc
  .tuple(playOnGridArb, playerArb)
  .map(([{ grid, selectedColumn }, player]) => {
    const clonedGrid = grid.map(row => row.slice());
    const selectedRow = computeNextRow(grid, selectedColumn);
    if (grid.length - selectedRow >= TestGridVictory) {
      for (let idx = 1; idx !== TestGridVictory; ++idx) clonedGrid[selectedRow + idx][selectedColumn] = player;
    } else {
      for (let idx = 1; idx !== TestGridVictory; ++idx) clonedGrid[clonedGrid.length - idx][selectedColumn] = player;
    }
    return { grid: clonedGrid, selectedColumn, player };
  });
export const topLeftDiagonalVictoryPlayOnGridArb = fc
  .tuple(playOnGridArb, playerArb, fc.integer(-TestGridVictory + 1, 0))
  .filter(([{ grid, selectedColumn }, _player, offset]) => {
    const selectedRow = computeNextRow(grid, selectedColumn);
    return (
      selectedColumn + offset >= 0 &&
      selectedColumn + offset + TestGridVictory <= grid[0].length &&
      selectedRow + offset >= 0 &&
      selectedRow + offset + TestGridVictory <= grid.length
    );
  })
  .map(([{ grid, selectedColumn }, player, offset]) => {
    const clonedGrid = grid.map(row => row.slice());
    const selectedRow = computeNextRow(grid, selectedColumn);
    for (let idx = 0; idx !== TestGridVictory; ++idx) {
      const row = selectedRow + offset + idx;
      const col = selectedColumn + offset + idx;
      if (col === selectedColumn) continue;
      replaceOrFillForPlayer(clonedGrid, player, row, col);
    }
    return { grid: clonedGrid, selectedColumn, player };
  });
export const topRightDiagonalVictoryPlayOnGridArb = fc
  .tuple(playOnGridArb, playerArb, fc.integer(-TestGridVictory + 1, 0))
  .filter(([{ grid, selectedColumn }, _player, offset]) => {
    const selectedRow = computeNextRow(grid, selectedColumn);
    return (
      selectedColumn + offset >= 0 &&
      selectedColumn + offset + TestGridVictory <= grid[0].length &&
      selectedRow - offset - TestGridVictory > 0 &&
      selectedRow - offset < grid.length
    );
  })
  .map(([{ grid, selectedColumn }, player, offset]) => {
    const clonedGrid = grid.map(row => row.slice());
    const selectedRow = computeNextRow(grid, selectedColumn);
    for (let idx = 0; idx !== TestGridVictory; ++idx) {
      const row = selectedRow - offset - idx;
      const col = selectedColumn + offset + idx;
      if (col === selectedColumn) continue;
      replaceOrFillForPlayer(clonedGrid, player, row, col);
    }
    return { grid: clonedGrid, selectedColumn, player };
  });
export const noVictoryPlayOnGridArb = fc
  .tuple(
    playOnGridArb,
    playerArb,
    fc.integer(-TestGridVictory + 2, -1),
    fc.integer(-TestGridVictory + 2, -1),
    fc.integer(-TestGridVictory + 2, -1),
    fc.integer(-TestGridVictory + 2, -1)
  )
  .map(([{ grid, selectedColumn }, player, offsetLine, offsetCol, offsetTL, offsetTR]) => {
    const otherPlayer = player === Player.PlayerA ? Player.PlayerB : Player.PlayerA;
    const clonedGrid = grid.map(row => row.slice());
    const selectedRow = computeNextRow(grid, selectedColumn);
    const updateGrid = (row: number, col: number) => {
      if (row < 0 || row >= clonedGrid.length) return;
      if (col < 0 || col >= clonedGrid[0].length) return;
      if (clonedGrid[row][col] === player) {
        clonedGrid[row][col] = otherPlayer;
      }
    };
    // no line will be possible
    updateGrid(selectedRow, selectedColumn + offsetLine);
    updateGrid(selectedRow, selectedColumn + offsetLine + TestGridVictory);
    // no column will be possible
    updateGrid(selectedRow - offsetCol, selectedColumn);
    // no top-left diagonal possible
    updateGrid(selectedRow + offsetLine, selectedColumn + offsetLine);
    updateGrid(selectedRow + offsetLine + TestGridVictory, selectedColumn + offsetLine + TestGridVictory);
    // no top-right diagonal possible
    updateGrid(selectedRow - offsetLine, selectedColumn + offsetLine);
    updateGrid(selectedRow - offsetLine - TestGridVictory, selectedColumn + offsetLine + TestGridVictory);
    return { grid: clonedGrid, selectedColumn, player };
  });
